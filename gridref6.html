<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP with Lunch Constraint</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 400px; margin-top: 20px; }
        .form-group { margin-bottom: 10px; }
    </style>
</head>
<body>

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        let waypointCount = 0;
        let map;
        
        function addWaypoint() {
            waypointCount++;
            const waypointDiv = document.createElement("div");
            waypointDiv.className = "form-group";
            waypointDiv.innerHTML = `
                <input type="text" id="waypoint-${waypointCount}" oninput="updateLatLon('waypoint-${waypointCount}')" placeholder="e.g., SO 600 100">
                <span id="waypoint-${waypointCount}-coords"></span>
            `;
            document.getElementById("waypoint-inputs").appendChild(waypointDiv);
        }

        function osGridToLatLon(osGridRef) {
            // Conversion logic (simplified for demonstration purposes)
            // Extract easting and northing from OS Grid Reference
            const matches = osGridRef.match(/([A-Z]{2})\s*(\d+)\s*(\d+)/i);
            if (!matches) return null;
            
            const gridLetters = matches[1].toUpperCase();
            let easting = parseInt(matches[2].padEnd(5, '0'));
            let northing = parseInt(matches[3].padEnd(5, '0'));
            
            // Convert grid letters to 100km offsets (example for OS grid system)
            const grid = {
                'S': { easting: 0, northing: 0 }
                // Add other grid letters as needed
            };
            if (grid[gridLetters]) {
                easting += grid[gridLetters].easting * 100000;
                northing += grid[gridLetters].northing * 100000;
            }
            
            // Dummy conversion to lat/lon for demonstration (replace with proper algorithm)
            const lat = 51.0 + (northing / 1000000);
            const lon = -2.0 + (easting / 1000000);
            return { lat, lon };
        }

        function updateLatLon(id) {
            const osGridRef = document.getElementById(id).value;
            const coords = osGridToLatLon(osGridRef);
            document.getElementById(`${id}-coords`).textContent = coords ? `Lat: ${coords.lat.toFixed(5)}, Lon: ${coords.lon.toFixed(5)}` : '';
        }

        function parseInputAndCalculate() {
            const data = {
                start: { osGridRef: document.getElementById("start").value, latLon: osGridToLatLon(document.getElementById("start").value) },
                lunch: { osGridRef: document.getElementById("lunch").value, latLon: osGridToLatLon(document.getElementById("lunch").value) },
                end: { osGridRef: document.getElementById("end").value, latLon: osGridToLatLon(document.getElementById("end").value) },
                waypoints: []
            };

            for (let i = 1; i <= waypointCount; i++) {
                const waypointInput = document.getElementById(`waypoint-${i}`);
                const waypointCoords = osGridToLatLon(waypointInput.value);
                if (waypointCoords) {
                    data.waypoints.push({
                        osGridRef: waypointInput.value,
                        latLon: waypointCoords,
                        label: `Waypoint ${i}`
                    });
                }
            }

            findOptimumRoutes(data);
        }

        let bestRoutesByLunchPosition = {};  // Store best routes per lunch position for map rendering

        // Haversine function for distance calculation
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const deltaPhi = phi2 - phi1;
            const deltaLambda = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(deltaPhi / 2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // Compute distance matrix
        function computeDistanceMatrix(locations) {
            const size = locations.length;
            const distanceMatrix = Array.from({ length: size }, () => Array(size).fill(0));
            for (let i = 0; i < size; i++) {
                for (let j = i + 1; j < size; j++) {
                    const dist = haversine(locations[i].lat, locations[i].lon, locations[j].lat, locations[j].lon);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
            return distanceMatrix;
        }

        // Generate all permutations
        function permutations(array) {
            if (array.length === 1) return [array];
            const result = [];
            for (let i = 0; i < array.length; i++) {
                const current = array[i];
                const remaining = array.slice(0, i).concat(array.slice(i + 1));
                const remainingPerms = permutations(remaining);
                for (let perm of remainingPerms) {
                    result.push([current, ...perm]);
                }
            }
            return result;
        }

        function findOptimumRoutes(data) {
            const start = data.start.latLon;
            const lunch = data.lunch.latLon;
            const end = data.end.latLon;
            const waypoints = data.waypoints;

            const waypointCoords = waypoints.map(wp => wp.latLon);
            const locationNames = ["Start", ...waypoints.map(wp => wp.label), "Lunch", "End"];
            const locations = [start, ...waypointCoords, lunch, end];
            const distanceMatrix = computeDistanceMatrix(locations);

            const numWaypoints = waypoints.length;
            const lunchPositions = [3, 4, 5];  // Allowed lunch positions
            const outputContainer = document.getElementById("output");
            outputContainer.innerHTML = "";  // Clear previous output

            lunchPositions.forEach(lunchPosition => {
                let minTotalCost = Infinity;
                let bestRoute;

                const waypointIndices = Array.from({ length: numWaypoints }, (_, i) => i + 1);  // Waypoint indices
                const allPermutations = permutations(waypointIndices);

                for (let perm of allPermutations) {
                    const route = [0, ...perm, numWaypoints + 2];  // Start and End
                    const routeWithLunch = [
                        ...route.slice(0, lunchPosition - 1), 
                        numWaypoints + 1, 
                        ...route.slice(lunchPosition - 1)
                    ]; // Insert lunch at the specified position

                    let totalCost = 0;
                    for (let i = 0; i < routeWithLunch.length - 1; i++) {
                        totalCost += distanceMatrix[routeWithLunch[i]][routeWithLunch[i + 1]];
                    }

                    if (totalCost < minTotalCost) {
                        minTotalCost = totalCost;
                        bestRoute = routeWithLunch;
                    }
                }

                // Store the best route for this lunch position for map rendering
                bestRoutesByLunchPosition[lunchPosition] = bestRoute.map(i => ({ ...locations[i], label: locationNames[i] }));

                // Display route text and add buttons for drawing map and generating GPX
                const routeText = bestRoute.map(i => locationNames[i]).join(" -> ");
                const distanceText = `Total distance: ${(minTotalCost / 1000).toFixed(2)} km`;
                
                const resultDiv = document.createElement("div");
                resultDiv.innerHTML = `<strong>Best route with Lunch at position ${lunchPosition}:</strong><br>${routeText}<br>${distanceText}<br>`;
                
                const drawMapButton = document.createElement("button");
                drawMapButton.textContent = `Draw Map for Lunch at ${lunchPosition}`;
                drawMapButton.onclick = () => drawMap(bestRoutesByLunchPosition[lunchPosition]);
                resultDiv.appendChild(drawMapButton);
                
                const gpxButton = document.createElement("button");
                gpxButton.textContent = `Generate GPX for Lunch at ${lunchPosition}`;
                gpxButton.onclick = () => generateGPX(bestRoutesByLunchPosition[lunchPosition], `Optimal_Route_Lunch_Position_${lunchPosition}.gpx`);
                resultDiv.appendChild(gpxButton);
                
                outputContainer.appendChild(resultDiv);
                outputContainer.appendChild(document.createElement("hr"));
            });
        }

        // GPX generation function
        function generateGPX(route, fileName) {
            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="OptimalRouteGenerator" xmlns="http://www.topografix.com/GPX/1/1">\n<trk><name>${fileName}</name><trkseg>\n`;
            
            route.forEach(({ lat, lon }) => {
                gpxContent += `<trkpt lat="${lat}" lon="${lon}"><ele>0</ele><time>${new Date().toISOString()}</time></trkpt>\n`;
            });
            
            gpxContent += "</trkseg></trk></gpx>";

            // Create a blob and download the GPX file
            const blob = new Blob([gpxContent], { type: "application/gpx+xml" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            link.click();
        }

        // Function to draw the map with Leaflet
        function drawMap(route) {
            if (map) {
                map.remove();  // Clear existing map
            }
            map = L.map('map').setView([route[0].lat, route[0].lon], 13);  // Center on start position

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            const colors = { Start: 'green', Lunch: 'orange', End: 'red' };
            route.forEach((point, index) => {
                const markerColor = colors[point.label] || 'blue';
                const marker = L.circleMarker([point.lat, point.lon], {
                    color: markerColor,
                    radius: 5,
                    fillOpacity: 1
                }).addTo(map);
                marker.bindPopup(`<strong>${point.label || "Waypoint"}</strong><br>OS Grid Ref: ${point.osGridRef || "N/A"}`);
            });

            const routeCoords = route.map(point => [point.lat, point.lon]);
            L.polyline(routeCoords, { color: 'blue' }).addTo(map);
        }
    </script>
	    <h1>Traveling Salesman Problem with Lunch Constraint</h1>

    <div>
        <h3>Enter Locations</h3>
        <div class="form-group">
            <label>Start (OS Grid Ref):</label>
            <input type="text" id="start" oninput="updateLatLon('start')" placeholder="e.g., SO 645 154">
            <span id="start-coords"></span>
        </div>
        <div class="form-group">
            <label>Lunch (OS Grid Ref):</label>
            <input type="text" id="lunch" oninput="updateLatLon('lunch')" placeholder="e.g., SO 622 122">
            <span id="lunch-coords"></span>
        </div>
        <div class="form-group">
            <label>End (OS Grid Ref):</label>
            <input type="text" id="end" oninput="updateLatLon('end')" placeholder="e.g., SO 654 154">
            <span id="end-coords"></span>
        </div>
        <div id="waypoints-container">
            <label>Waypoints (OS Grid Ref):</label>
            <button onclick="addWaypoint()">Add Waypoint</button>
            <div id="waypoint-inputs"></div>
        </div>
        <button onclick="parseInputAndCalculate()">Calculate Optimal Routes</button>
    </div>

    <div id="output"></div>
    <div id="map"></div> <!-- Container for the map -->
</body>
</html>
