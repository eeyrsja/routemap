<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TSP with Lunch Constraint</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 400px; margin-top: 20px; }
    </style>
</head>
<body>

    <h1>Traveling Salesman Problem with Lunch Constraint</h1>
    <button onclick="findOptimumRoutes()">Calculate Optimal Routes</button>
    <div id="output"></div>
    <div id="map"></div> <!-- Container for the map -->

    <!-- Leaflet JavaScript -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

    <script>
        // Provided data with new waypoints
        const data = {
            start: {
                osGridRef: "so627095",
                latLon: { lat: 51.782910189658246, lon: -2.5421081751230923 }
            },
            lunch: {
                osGridRef: "so622122",
                latLon: { lat: 51.80715113831243, lon: -2.5496510676062476 }
            },
            end: {
                osGridRef: "so654154",
                latLon: { lat: 51.836072, lon: -2.516623 }
            },
            waypoints: [
                { label: "ruspidge", osGridRef: "so650126", latLon: { lat: 51.810930275826536, lon: -2.509082456851173 } },
                { label: "speculation", osGridRef: "so611134", latLon: { lat: 51.81786410611253, lon: -2.565739675264192 } },
                { label: "roundfence", osGridRef: "so645154", latLon: { lat: 51.836072, lon: -2.516623 } },
                { label: "sapling", osGridRef: "so623102", latLon: { lat: 51.7891767272659, lon: -2.547982631037622 } },
                { label: "sculpture", osGridRef: "so624125", latLon: { lat: 51.809861839969855, lon: -2.54678307948389 } },
                { label: "dead tree", osGridRef: "so608108", latLon: { lat: 51.794467661082656, lon: -2.56979671231002 } }
            ]
        };

        let bestRoutesByLunchPosition = {};  // Store best routes per lunch position for map rendering
        let map;  // Define map globally

        // Haversine function for distance calculation
        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180;
            const phi2 = lat2 * Math.PI / 180;
            const deltaPhi = phi2 - phi1;
            const deltaLambda = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(deltaPhi / 2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * Math.sin(deltaLambda / 2) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // Compute distance matrix
        function computeDistanceMatrix(locations) {
            const size = locations.length;
            const distanceMatrix = Array.from({ length: size }, () => Array(size).fill(0));
            for (let i = 0; i < size; i++) {
                for (let j = i + 1; j < size; j++) {
                    const dist = haversine(locations[i].lat, locations[i].lon, locations[j].lat, locations[j].lon);
                    distanceMatrix[i][j] = dist;
                    distanceMatrix[j][i] = dist;
                }
            }
            return distanceMatrix;
        }

        // Generate all permutations
        function permutations(array) {
            if (array.length === 1) return [array];
            const result = [];
            for (let i = 0; i < array.length; i++) {
                const current = array[i];
                const remaining = array.slice(0, i).concat(array.slice(i + 1));
                const remainingPerms = permutations(remaining);
                for (let perm of remainingPerms) {
                    result.push([current, ...perm]);
                }
            }
            return result;
        }

        function findOptimumRoutes() {
            const start = data.start.latLon;
            const lunch = data.lunch.latLon;
            const end = data.end.latLon;
            const waypoints = data.waypoints;

            const waypointCoords = waypoints.map(wp => wp.latLon);
            const locationNames = ["Start", ...waypoints.map(wp => wp.label), "Lunch", "End"];
            const locations = [start, ...waypointCoords, lunch, end];
            const distanceMatrix = computeDistanceMatrix(locations);

            const numWaypoints = waypoints.length;
            const lunchPositions = [3, 4, 5];  // Allowed lunch positions
            const outputContainer = document.getElementById("output");
            outputContainer.innerHTML = "";  // Clear previous output

            lunchPositions.forEach(lunchPosition => {
                let minTotalCost = Infinity;
                let bestRoute;

                const waypointIndices = Array.from({ length: numWaypoints }, (_, i) => i + 1);  // Waypoint indices
                const allPermutations = permutations(waypointIndices);

                for (let perm of allPermutations) {
                    const route = [0, ...perm, numWaypoints + 2];  // Start and End
                    const routeWithLunch = [
                        ...route.slice(0, lunchPosition - 1), 
                        numWaypoints + 1, 
                        ...route.slice(lunchPosition - 1)
                    ]; // Insert lunch at the specified position

                    let totalCost = 0;
                    for (let i = 0; i < routeWithLunch.length - 1; i++) {
                        totalCost += distanceMatrix[routeWithLunch[i]][routeWithLunch[i + 1]];
                    }

                    if (totalCost < minTotalCost) {
                        minTotalCost = totalCost;
                        bestRoute = routeWithLunch;
                    }
                }

                // Store the best route for this lunch position for map rendering
                bestRoutesByLunchPosition[lunchPosition] = bestRoute.map(i => ({ ...locations[i], label: locationNames[i] }));

                // Display route text and add buttons for drawing map and generating GPX
                const routeText = bestRoute.map(i => locationNames[i]).join(" -> ");
                const distanceText = `Total distance: ${(minTotalCost / 1000).toFixed(2)} km`;
                
                const resultDiv = document.createElement("div");
                resultDiv.innerHTML = `<strong>Best route with Lunch at position ${lunchPosition}:</strong><br>${routeText}<br>${distanceText}<br>`;
                
                const drawMapButton = document.createElement("button");
                drawMapButton.textContent = `Draw Map for Lunch at ${lunchPosition}`;
                drawMapButton.onclick = () => drawMap(bestRoutesByLunchPosition[lunchPosition]);
                resultDiv.appendChild(drawMapButton);
                
                const gpxButton = document.createElement("button");
                gpxButton.textContent = `Generate GPX for Lunch at ${lunchPosition}`;
                gpxButton.onclick = () => generateGPX(bestRoutesByLunchPosition[lunchPosition], `Optimal_Route_Lunch_Position_${lunchPosition}.gpx`);
                resultDiv.appendChild(gpxButton);
                
                outputContainer.appendChild(resultDiv);
                outputContainer.appendChild(document.createElement("hr"));
            });
        }

        // GPX generation function
        function generateGPX(route, fileName) {
            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>\n<gpx version="1.1" creator="OptimalRouteGenerator" xmlns="http://www.topografix.com/GPX/1/1">\n<trk><name>${fileName}</name><trkseg>\n`;
            
            route.forEach(({ lat, lon }) => {
                gpxContent += `<trkpt lat="${lat}" lon="${lon}"><ele>0</ele><time>${new Date().toISOString()}</time></trkpt>\n`;
            });
            
            gpxContent += "</trkseg></trk></gpx>";

            // Create a blob and download the GPX file
            const blob = new Blob([gpxContent], { type: "application/gpx+xml" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            link.click();
        }

        // Function to draw the map with Leaflet
        function drawMap(route) {
            if (map) {
                map.remove();  // Clear existing map
            }
            map = L.map('map').setView([data.lunch.latLon.lat, data.lunch.latLon.lon], 13);  // Center on lunch position

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 18,
                attribution: 'Â© OpenStreetMap contributors'
            }).addTo(map);

            const colors = { Start: 'green', Lunch: 'orange', End: 'red' };
            route.forEach((point, index) => {
                const markerColor = colors[point.label] || 'blue';
                const marker = L.circleMarker([point.lat, point.lon], {
                    color: markerColor,
                    radius: 5,
                    fillOpacity: 1
                }).addTo(map);
                marker.bindPopup(`<strong>${point.label || "Waypoint"}</strong><br>OS Grid Ref: ${point.osGridRef || "N/A"}`);
            });

            const routeCoords = route.map(point => [point.lat, point.lon]);
            L.polyline(routeCoords, { color: 'blue' }).addTo(map);
        }
    </script>
</body>
</html>
